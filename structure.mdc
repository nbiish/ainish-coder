---
alwaysApply: true
---
# Structure Rule: Logical Tiered Composition

All code should be organized using a tiered component structure for clarity, maintainability, and robustness. The recommended tiers are:

1. **Quanta**: The smallest, indivisible units of logic (e.g., pure functions, constants, utility helpers).
2. **Atom**: Simple, self-contained components built from quanta (e.g., a single-purpose class, a basic UI element, or a CLI argument parser).
3. **Molecule**: Composed of multiple atoms and/or quanta, representing a meaningful functional unit (e.g., a command handler, a composite UI widget, or a data processing pipeline).
4. **Matter**: High-level modules or features composed of molecules, atoms, and quanta, representing a complete workflow or user-facing feature (e.g., a CLI command, a service endpoint, or a full UI page).
5. **Matter Phase**: A phase of a matter, representing a complete workflow or user-facing feature (e.g., a CLI command, a service endpoint, or a full UI page).
6. **Lifeform**: A complete application, representing a complete product experience (e.g., a CLI, a web app, or a mobile app).

## Technical/Methodology Choices

- Each tier should only depend on the tiers below it (e.g., molecules depend on atoms/quanta).
- This structure enables robust testing, refactoring, and feature extension.
- When designing new features, making fixes, or refactoring, always identify the appropriate tier for each component and document its role in the PRD.md and knowledge base.

## Example Usage

### When implementing a new feature

- Define quanta (e.g., string validators, file path resolvers).
- Build atoms (e.g., argument parser, output formatter).
- Compose molecules (e.g., command handler combining parser and formatter).
- Molecules form into matter (e.g., the command module).
- Matter phases create the lifeform (e.g., a CLI, a web app, or a mobile app).

This process enforces a clear, scalable, and robust architecture by decomposing complexity into well-defined, reusable components. The process aligns with modern best practices for maintainable and testable codebases. This process is crucial to planning, reviewing, fixing, and refactoring good code.

## Directory and File Scripting

All directory and file management scripting should be done from orderly, organized, and maintainable scripts in a subdirectory of a repository called `mgmt-scripts/`.

EXAMPLE:

```bash
mgmt-scripts/
⮑ cleanup/
    ⮑ cleanup.sh
⮑ rename/
    ⮑ rename.sh
⮑ organize/
    ⮑ organize.sh
```
