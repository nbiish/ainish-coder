#!/bin/bash

# AINISH-Coder Unified Setup Script
# This script sets up all tooling configurations in one go and provides wrapper functions

#########################################################################
# FUNCTION REFERENCE
#########################################################################
# Main Functions:
# - setup_ainish_coder_dir(): Creates ~/.ainish-coder and sets up symlinks to repository
# - verify_tool_paths(): Checks if configured tool paths exist
# - cleanup_old_files(): Removes old configuration files from previous versions
# - deploy_ainish_configs(): Deploys all AINISH configurations to a target directory
# - update_gitignore(): Updates .gitignore with AINISH-related entries
# - setup_wrapper_functions(): Adds wrapper functions to .zshrc
# - deploy_vscode_configs(): Deploys only VS Code/Copilot specific configurations
# - deploy_cursor_configs(): Deploys only Cursor specific configurations
# - deploy_aider_configs(): Deploys only Aider specific configurations
# - update_critical_mdc(): Updates critical.mdc in all ainish-* directories
# - update_prd_mdc(): Updates PRD.mdc in all ainish-* directories
# - update_prompt_md(): Updates prompt.md in all ainish-* directories
# - main(): Main execution function that processes command arguments
#
# Usage Examples:
# ./ainish-setup.sh                     # Run full setup
# ./ainish-setup.sh deploy /path/dir    # Deploy all configs to specified directory
# ./ainish-setup.sh deploy_cursor_configs /path/dir  # Deploy only Cursor configs
# ./ainish-setup.sh deploy_vscode_configs /path/dir  # Deploy only VS Code configs
# ./ainish-setup.sh deploy_aider_configs /path/dir   # Deploy only Aider configs
# ./ainish-setup.sh update_critical_mdc  # Update critical.mdc in all ainish-* dirs
#########################################################################

# Get the absolute path of the repository and export it
export REPO_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ZSHRC="${HOME}/.zshrc"
AINISH_CODER_DIR="${HOME}/.ainish-coder"

# Configuration variables - Edit these to match your installation paths
export CURSOR_PATH="/Applications/Cursor.app/Contents/MacOS/Cursor"
export VSCODE_PATH="code"  # Assuming 'code' is in PATH
export AIDER_PATH="aider"  # Assuming 'aider' is in PATH

# ANSI color codes for cyberpunk theme
CYAN='\033[0;36m'
BRIGHT_CYAN='\033[1;36m'
MAGENTA='\033[0;35m'
BRIGHT_MAGENTA='\033[1;35m'
BLUE='\033[0;34m'
BRIGHT_BLUE='\033[1;34m'
GREEN='\033[0;32m'
BRIGHT_GREEN='\033[1;32m'
YELLOW='\033[0;33m'
BRIGHT_YELLOW='\033[1;33m'
RED='\033[0;31m'
BRIGHT_RED='\033[1;31m'
RESET='\033[0m'

# Function to create and populate ~/.ainish-coder directory
setup_ainish_coder_dir() {
  echo -e "${BRIGHT_CYAN}ğŸ”§ Setting up ~/.ainish-coder directory...${RESET}"
  
  # Create the main directory
  mkdir -p "${AINISH_CODER_DIR}" 2>/dev/null
  
  # Remove existing directories if they exist
  rm -rf "${AINISH_CODER_DIR}/cursor" 2>/dev/null
  rm -rf "${AINISH_CODER_DIR}/vscode" 2>/dev/null
  rm -rf "${AINISH_CODER_DIR}/aider" 2>/dev/null
  
  # Create symlinks to original repo directories instead of copying
  ln -sf "${REPO_DIR}/ainish-cursor" "${AINISH_CODER_DIR}/cursor" 2>/dev/null
  ln -sf "${REPO_DIR}/ainish-copilot" "${AINISH_CODER_DIR}/vscode" 2>/dev/null
  ln -sf "${REPO_DIR}/ainish-aider" "${AINISH_CODER_DIR}/aider" 2>/dev/null
  
  # Create symlink for critical.mdc
  ln -sf "${REPO_DIR}/critical.mdc" "${AINISH_CODER_DIR}/critical.mdc" 2>/dev/null

  # Create symlink for PRD.mdc
  ln -sf "${REPO_DIR}/PRD.mdc" "${AINISH_CODER_DIR}/PRD.mdc" 2>/dev/null
  
  # Copy the setup script itself (this should be a copy, not a symlink)
  cp "${REPO_DIR}/ainish-setup.sh" "${AINISH_CODER_DIR}/ainish-setup.sh" 2>/dev/null
  chmod +x "${AINISH_CODER_DIR}/ainish-setup.sh" 2>/dev/null
  
  # Create a config file with the repository path
  echo "REPO_DIR=\"${REPO_DIR}\"" > "${AINISH_CODER_DIR}/config.sh"
  echo "# This file was automatically generated by ainish-setup.sh" >> "${AINISH_CODER_DIR}/config.sh"
  echo "# It contains paths to the original repository and is used by the ainish-update function" >> "${AINISH_CODER_DIR}/config.sh"
  chmod +x "${AINISH_CODER_DIR}/config.sh" 2>/dev/null
  
  echo -e "${BRIGHT_GREEN}âœ… ~/.ainish-coder directory setup complete with symlinks to repo${RESET}"
  echo -e "${GREEN}âœ“ Changes to repo files will be immediately available to tools${RESET}"
}

# Verify the tool paths exist (for those that are files)
verify_tool_paths() {
  local errors=0
  
  if [[ "$CURSOR_PATH" == /* && ! -f "$CURSOR_PATH" ]]; then
    echo -e "${BRIGHT_YELLOW}âš ï¸  Warning: Cursor not found at $CURSOR_PATH${RESET}"
    echo -e "${YELLOW}Please edit the CURSOR_PATH variable in ainish-setup.sh${RESET}"
    errors=$((errors+1))
  fi
  
  # For commands in PATH, just check if they're available
  if ! command -v "$VSCODE_PATH" &> /dev/null; then
    echo -e "${BRIGHT_YELLOW}âš ï¸  Warning: VS Code command '$VSCODE_PATH' not found in PATH${RESET}"
    echo -e "${YELLOW}Please edit the VSCODE_PATH variable in ainish-setup.sh${RESET}"
    errors=$((errors+1))
  fi
  
  if ! command -v "$AIDER_PATH" &> /dev/null; then
    echo -e "${BRIGHT_YELLOW}âš ï¸  Warning: Aider command '$AIDER_PATH' not found in PATH${RESET}"
    echo -e "${YELLOW}Please edit the AIDER_PATH variable in ainish-setup.sh${RESET}"
    errors=$((errors+1))
  fi
  
  if [ $errors -gt 0 ]; then
    return 1
  fi
  return 0
}

# Clean up old ainish-coder files from home directory
cleanup_old_files() {
  echo -e "${BRIGHT_CYAN}ğŸ§¹ Cleaning up old ainish-coder files from home directory...${RESET}"
  
  # Remove old setup scripts
  rm -f "${HOME}/setup.sh" "${HOME}/install.sh" "${HOME}/vscode-setup.sh" 2>/dev/null
  
  # Remove old configuration directories (but not ~/.ainish-coder)
  rm -rf "${HOME}/.ainish-cursor" "${HOME}/.ainish-aider" "${HOME}/.ainish-copilot" 2>/dev/null
  
  # Remove old configuration files
  rm -f "${HOME}/.ainish-config" "${HOME}/.ainish-settings" 2>/dev/null
  
  echo -e "${BRIGHT_GREEN}âœ… Cleanup complete${RESET}"
}

# Helper function to prompt for ignore files
prompt_for_ignore_files() {
  local TARGET="$1"
  local TOOL="$2"
  local FILE="$3"
  local DESC="$4"
  local RESPONSE=""

  # Skip if file already exists in target
  if [ -f "$TARGET/$FILE" ]; then
    echo -e "${BLUE}âœ“ $FILE already exists in target directory, skipping${RESET}"
    return 1
  fi

  echo -e "${BRIGHT_CYAN}Would you like to include $FILE for $TOOL?${RESET}"
  echo -e "${CYAN}$DESC${RESET}"
  echo -e "${BRIGHT_CYAN}[Y/n]:${RESET} "
  read -r RESPONSE

  # Default to yes if empty response
  if [[ -z "$RESPONSE" ]] || [[ "$RESPONSE" =~ ^[Yy] ]]; then
    return 0
  fi
  return 1
}

# Main deployment function
deploy_ainish_configs() {
  local TARGET="$1"
  
  # Verify target is a directory
  if [ ! -d "$TARGET" ]; then
    echo -e "${BRIGHT_RED}Error: $TARGET is not a directory${RESET}"
    return 1
  fi
  
  echo -e "${BRIGHT_BLUE}Deploying AINISH configurations to $TARGET${RESET}"
  
  # Create necessary directories
  mkdir -p "$TARGET/.cursor/rules" 2>/dev/null
  mkdir -p "$TARGET/.github" 2>/dev/null
  
  # Deploy Cursor configurations
  if prompt_for_ignore_files "$TARGET" "Cursor" ".cursorignore" "Controls which files Cursor AI will ignore during code generation and analysis."; then
    if [ -f "${AINISH_CODER_DIR}/cursor/.cursorignore" ]; then
      cp "${AINISH_CODER_DIR}/cursor/.cursorignore" "$TARGET/" 2>/dev/null
      echo -e "${GREEN}âœ“ Deployed .cursorignore${RESET}"
    else
      # Create empty .cursorignore if it doesn't exist
      touch "$TARGET/.cursorignore" 2>/dev/null
      echo -e "${GREEN}âœ“ Created empty .cursorignore${RESET}"
    fi
  fi
  
  if prompt_for_ignore_files "$TARGET" "Cursor" ".cursorindexingignore" "Controls which files Cursor will skip during indexing (improves performance)."; then
    if [ -f "${AINISH_CODER_DIR}/cursor/.cursorindexingignore" ]; then
      cp "${AINISH_CODER_DIR}/cursor/.cursorindexingignore" "$TARGET/" 2>/dev/null
      echo -e "${GREEN}âœ“ Deployed .cursorindexingignore${RESET}"
    else
      # Create empty .cursorindexingignore if it doesn't exist
      touch "$TARGET/.cursorindexingignore" 2>/dev/null
      echo -e "${GREEN}âœ“ Created empty .cursorindexingignore${RESET}"
    fi
  fi
  
  if [ -d "${AINISH_CODER_DIR}/cursor/.cursorrules" ]; then
    cp -r "${AINISH_CODER_DIR}/cursor/.cursorrules" "$TARGET/" 2>/dev/null
    echo -e "${GREEN}âœ“ Deployed .cursorrules/${RESET}"
  fi
  
  if [ -f "${AINISH_CODER_DIR}/cursor/my-license.mdc" ]; then
    cp "${AINISH_CODER_DIR}/cursor/my-license.mdc" "$TARGET/.cursor/rules/license.mdc" 2>/dev/null
    echo -e "${GREEN}âœ“ Deployed Cursor-specific license.mdc${RESET}"
  fi
  
  # Deploy shared critical.mdc and PRD.mdc
  if [ -f "${AINISH_CODER_DIR}/critical.mdc" ]; then
    cp "${AINISH_CODER_DIR}/critical.mdc" "$TARGET/.cursor/rules/" 2>/dev/null
    echo -e "${GREEN}âœ“ Deployed critical.mdc to .cursor/rules/${RESET}"
    
    if [ -d "$TARGET/.github" ]; then
      cp "${AINISH_CODER_DIR}/critical.mdc" "$TARGET/.github/" 2>/dev/null
      echo -e "${GREEN}âœ“ Deployed critical.mdc to .github/${RESET}"
    fi
  fi
  
  if [ -f "${AINISH_CODER_DIR}/PRD.mdc" ]; then
    cp "${AINISH_CODER_DIR}/PRD.mdc" "$TARGET/.cursor/rules/" 2>/dev/null
    echo -e "${GREEN}âœ“ Deployed PRD.mdc to .cursor/rules/${RESET}"
    
    if [ -d "$TARGET/.github" ]; then
      cp "${AINISH_CODER_DIR}/PRD.mdc" "$TARGET/.github/" 2>/dev/null
      echo -e "${GREEN}âœ“ Deployed PRD.mdc to .github/${RESET}"
    fi
  fi
  
  # Deploy Copilot configurations
  if prompt_for_ignore_files "$TARGET" "Copilot" ".copilotignore" "Controls which files GitHub Copilot will ignore during code suggestions."; then
    if [ -f "${AINISH_CODER_DIR}/vscode/.copilotignore" ]; then
      cp "${AINISH_CODER_DIR}/vscode/.copilotignore" "$TARGET/" 2>/dev/null
      echo -e "${GREEN}âœ“ Deployed .copilotignore${RESET}"
    fi
  fi
  
  # Only copy .rooignore if user wants it
  if prompt_for_ignore_files "$TARGET" "Copilot" ".rooignore" "Controls which files are excluded from Copilot's context window."; then
    if [ -f "${AINISH_CODER_DIR}/vscode/.rooignore" ]; then
      cp "${AINISH_CODER_DIR}/vscode/.rooignore" "$TARGET/" 2>/dev/null
      echo -e "${GREEN}âœ“ Deployed .rooignore${RESET}"
    fi
  fi
  
  # Deploy custom copilot instructions from ainish-copilot
  if [ -f "${AINISH_CODER_DIR}/vscode/.github/copilot-instructions.md" ]; then
    mkdir -p "$TARGET/.github" 2>/dev/null
    cp "${AINISH_CODER_DIR}/vscode/.github/copilot-instructions.md" "$TARGET/.github/" 2>/dev/null
    echo -e "${GREEN}âœ“ Deployed custom copilot-instructions.md from ainish-copilot${RESET}"
  fi

  # Deploy Aider configurations
  if prompt_for_ignore_files "$TARGET" "Aider" ".aiderignore" "Controls which files Aider will ignore during code generation and edits."; then
    if [ -f "${AINISH_CODER_DIR}/aider/.aiderignore" ]; then
      cp "${AINISH_CODER_DIR}/aider/.aiderignore" "$TARGET/" 2>/dev/null
      echo -e "${GREEN}âœ“ Deployed .aiderignore${RESET}"
    fi
  fi
  
  if [ -f "${AINISH_CODER_DIR}/aider/.aider.conf.yml" ]; then
    cp "${AINISH_CODER_DIR}/aider/.aider.conf.yml" "$TARGET/" 2>/dev/null
    echo -e "${GREEN}âœ“ Deployed .aider.conf.yml${RESET}"
  fi
  
  if [ -f "${AINISH_CODER_DIR}/aider/.env.example" ]; then
    cp "${AINISH_CODER_DIR}/aider/.env.example" "$TARGET/" 2>/dev/null
    echo -e "${GREEN}âœ“ Deployed .env.example${RESET}"
  fi
  
  if [ -f "${AINISH_CODER_DIR}/aider/aider-cli-commands.sh" ]; then
    cp "${AINISH_CODER_DIR}/aider/aider-cli-commands.sh" "$TARGET/" 2>/dev/null
    chmod +x "$TARGET/aider-cli-commands.sh" 2>/dev/null # Ensure executable
    echo -e "${GREEN}âœ“ Deployed aider-cli-commands.sh${RESET}"
  fi
  
  # Deploy shared critical.mdc
  if [ -f "${AINISH_CODER_DIR}/critical.mdc" ]; then
    cp "${AINISH_CODER_DIR}/critical.mdc" "$TARGET/.github/" 2>/dev/null
    echo -e "${GREEN}âœ“ Deployed critical.mdc to .github/${RESET}"
  fi
  
  # Deploy shared critical.mdc directly to target directory, not to .aider subfolder
  if [ -f "${AINISH_CODER_DIR}/critical.mdc" ]; then
    cp "${AINISH_CODER_DIR}/critical.mdc" "$TARGET/" 2>/dev/null
    echo -e "${GREEN}âœ“ Deployed critical.mdc to $TARGET${RESET}"
  fi
  
  # Update .gitignore
  update_gitignore "$TARGET"
  
  echo -e "${BRIGHT_GREEN}âœ… AINISH configurations deployed to $TARGET${RESET}"
}

# Function to update .gitignore
update_gitignore() {
  local TARGET="$1"
  local GITIGNORE="$TARGET/.gitignore"
  
  # Config entries to add to .gitignore
  local ENTRIES=(
    "# Cursor files"
    ".cursor/"
    ".cursorignore"
    ".cursorindexingignore"
    ".cursorrules"
    ""
    "# Aider files"
    ".aider-instructions.md"
    ".aider.conf.yml"
    ".aiderignore"
    ".env.example"
    ""
    "# Copilot files"
    ".copilot/"
    ".copilotignore"
    ".rooignore"
    ".github/copilot-instructions.md"
  )
  
  if [ -f "$GITIGNORE" ]; then
    # Check if entries already exist
    if ! grep -q ".cursorignore\|.copilotignore" "$GITIGNORE"; then
      echo "" >> "$GITIGNORE"
      for entry in "${ENTRIES[@]}"; do
        echo "$entry" >> "$GITIGNORE"
      done
      echo -e "${BLUE}Updated .gitignore with AINISH config entries${RESET}"
    else
      echo -e "${BLUE}.gitignore already contains AINISH entries${RESET}"
    fi
  else
    # Create new .gitignore
    for entry in "${ENTRIES[@]}"; do
      echo "$entry" >> "$GITIGNORE"
    done
    echo -e "${BLUE}Created .gitignore with AINISH config entries${RESET}"
  fi

  # Verify .gitignore was created/updated successfully
  if [ -f "$GITIGNORE" ]; then
    echo -e "${GREEN}âœ“ Verified .gitignore exists${RESET}"
  else
    echo -e "${YELLOW}âš ï¸ Warning: Failed to create .gitignore${RESET}"
  fi
}

# Setup wrapper functions in .zshrc
setup_wrapper_functions() {
  if [ ! -f "$ZSHRC" ]; then
    echo -e "${YELLOW}âš ï¸  Warning: ~/.zshrc not found. Please manually add the wrapper functions.${RESET}"
    return
  fi
  
  echo -e "${BRIGHT_BLUE}ğŸ”§ Updating .zshrc with wrapper functions...${RESET}"
  
  # Remove existing wrapper sections if they exist
  sed -i '' '/### AINISH CODER WRAPPERS ###/,/### END AINISH CODER WRAPPERS ###/d' "$ZSHRC" 2>/dev/null
  
  # First export the AINISH_CODER_DIR
  cat >> "$ZSHRC" << EOF
### AINISH CODER WRAPPERS ###
# Export AINISH-Coder paths
export AINISH_CODER_DIR="${AINISH_CODER_DIR}"
export CURSOR_PATH="$CURSOR_PATH"
export VSCODE_PATH="$VSCODE_PATH"
export AIDER_PATH="$AIDER_PATH"
export REPO_DIR="$REPO_DIR"

EOF

  # Then add the functions
  cat >> "$ZSHRC" << 'EOF'
# AINISH-Coder wrapper functions
function ainish-coder {
  # Capture current directory explicitly to handle external volumes
  local CURRENT_DIR="$(pwd)"
  
  # Deploy from the linked repo directories to ensure latest changes are used
  "$AINISH_CODER_DIR/ainish-setup.sh" deploy "$CURRENT_DIR"
  echo "âœ¨ AINISH-Coder configurations deployed to current directory"
  echo "ğŸ”„ Using symlinks to repository - changes to repo files are immediately available"
}

function ainish-cursor {
  # Capture current directory explicitly to handle external volumes
  local CURRENT_DIR="$(pwd)"
  
  # Deploy from the linked repo directories to ensure latest changes are used
  "$AINISH_CODER_DIR/ainish-setup.sh" deploy_cursor_configs "$CURRENT_DIR"
  echo "ğŸ”„ Using symlinked configuration - changes to repo files are immediately available"
  if [[ "$1" == -* ]]; then
    "$CURSOR_PATH" "$@"
  else
    "$CURSOR_PATH" "$@"
  fi
}

function ainish-aider {
  # Capture current directory explicitly to handle external volumes
  local CURRENT_DIR="$(pwd)"
  
  # Deploy from the linked repo directories to ensure latest changes are used
  "$AINISH_CODER_DIR/ainish-setup.sh" deploy_aider_configs "$CURRENT_DIR"
  echo "ğŸ”„ Using symlinked configuration - changes to repo files are immediately available"
  "$AIDER_PATH" "$@"
}

function ainish-copilot {
  # Capture current directory explicitly to handle external volumes
  local CURRENT_DIR="$(pwd)"
  
  # Deploy from the linked repo directories to ensure latest changes are used
  "$AINISH_CODER_DIR/ainish-setup.sh" deploy_vscode_configs "$CURRENT_DIR"
  echo "ğŸ”„ Using symlinked configuration - changes to repo files are immediately available"
  if [[ "$1" == -* ]]; then
    "$VSCODE_PATH" "$@"
  else
    "$VSCODE_PATH" "$@"
  fi
}

# Function to update the AINISH-Coder installation from the repository
function ainish-update {
  echo "ğŸ”„ Updating AINISH-Coder from repository..."
  # Try to load REPO_DIR from config if not set
  if [ -z "$REPO_DIR" ] && [ -f "$AINISH_CODER_DIR/config.sh" ]; then
    source "$AINISH_CODER_DIR/config.sh"
  fi
  # Run the update command from the setup script
  if [ -d "$REPO_DIR" ]; then
    "$REPO_DIR/ainish-setup.sh" update
    echo "âœ… AINISH-Coder updated successfully"
  else
    echo "âŒ Repository directory not found. Please set REPO_DIR environment variable."
  fi
}
### END AINISH CODER WRAPPERS ###
EOF

  echo -e "${BRIGHT_GREEN}âœ… Wrapper functions added to .zshrc${RESET}"
}

# Function to deploy only VS Code configurations
deploy_vscode_configs() {
  local TARGET="$1"

  # Verify target is a directory
  if [ ! -d "$TARGET" ]; then
    echo -e "${BRIGHT_RED}Error: $TARGET is not a directory${RESET}"
    return 1
  fi

  echo -e "${BRIGHT_BLUE}Deploying VS Code configurations to $TARGET${RESET}"

  # Create necessary directories
  mkdir -p "$TARGET/.github" 2>/dev/null
  
  # Deploy VS Code-specific configurations
  if prompt_for_ignore_files "$TARGET" "Copilot" ".copilotignore" "Controls which files GitHub Copilot will ignore during code suggestions."; then
    if [ -f "${AINISH_CODER_DIR}/vscode/.copilotignore" ]; then
      cp "${AINISH_CODER_DIR}/vscode/.copilotignore" "$TARGET/" 2>/dev/null
      echo -e "${GREEN}âœ“ Deployed .copilotignore${RESET}"
    fi
  fi

  # Only copy .rooignore if user wants it
  if prompt_for_ignore_files "$TARGET" "Copilot" ".rooignore" "Controls which files are excluded from Copilot's context window."; then
    if [ -f "${AINISH_CODER_DIR}/vscode/.rooignore" ]; then
      cp "${AINISH_CODER_DIR}/vscode/.rooignore" "$TARGET/" 2>/dev/null
      echo -e "${GREEN}âœ“ Deployed .rooignore${RESET}"
    fi
  fi

  # Deploy custom copilot instructions from ainish-copilot
  if [ -f "${AINISH_CODER_DIR}/vscode/.github/copilot-instructions.md" ]; then
    mkdir -p "$TARGET/.github" 2>/dev/null
    cp "${AINISH_CODER_DIR}/vscode/.github/copilot-instructions.md" "$TARGET/.github/" 2>/dev/null
    echo -e "${GREEN}âœ“ Deployed custom copilot-instructions.md from ainish-copilot${RESET}"
  fi

  # Fallback: copy copilot-instructions.md from root prompt.md if no custom file
  if [ ! -f "$TARGET/.github/copilot-instructions.md" ]; then
    local prompt_source="${REPO_DIR}/prompt.md"
    local copilot_target_dir="$TARGET/.github"
    local copilot_target_file="$copilot_target_dir/copilot-instructions.md"
    if [ -f "$prompt_source" ]; then
      mkdir -p "$copilot_target_dir" 2>/dev/null
      cp "$prompt_source" "$copilot_target_file" 2>/dev/null
      echo -e "${GREEN}âœ“ Deployed $copilot_target_file (from root prompt.md)${RESET}"
    else
      echo -e "${YELLOW}âš ï¸ Warning: Source prompt.md not found at $prompt_source${RESET}"
    fi
  fi

  # Deploy shared critical.mdc and PRD.mdc
  if [ -f "${AINISH_CODER_DIR}/critical.mdc" ]; then
    cp "${AINISH_CODER_DIR}/critical.mdc" "$TARGET/.github/" 2>/dev/null
    echo -e "${GREEN}âœ“ Deployed critical.mdc to .github/${RESET}"
  fi

  if [ -f "${AINISH_CODER_DIR}/PRD.mdc" ]; then
    cp "${AINISH_CODER_DIR}/PRD.mdc" "$TARGET/.github/" 2>/dev/null
    echo -e "${GREEN}âœ“ Deployed PRD.mdc to .github/${RESET}"
  fi

  echo -e "${BRIGHT_GREEN}âœ… VS Code configurations deployed to $TARGET${RESET}"
}

# Function to deploy only Cursor configurations
deploy_cursor_configs() {
  local TARGET="$1"

  # Verify target is a directory
  if [ ! -d "$TARGET" ]; then
    echo -e "${BRIGHT_RED}Error: $TARGET is not a directory${RESET}"
    return 1
  fi

  echo -e "${BRIGHT_BLUE}Deploying Cursor configurations to $TARGET${RESET}"
  
  # Create necessary directories
  mkdir -p "$TARGET/.cursor/rules" 2>/dev/null
  
  # Deploy Cursor-specific configurations
  if prompt_for_ignore_files "$TARGET" "Cursor" ".cursorignore" "Controls which files Cursor AI will ignore during code generation and analysis."; then
    if [ -f "${AINISH_CODER_DIR}/cursor/.cursorignore" ]; then
      cp "${AINISH_CODER_DIR}/cursor/.cursorignore" "$TARGET/" 2>/dev/null
      echo -e "${GREEN}âœ“ Deployed .cursorignore${RESET}"
    else
      # Create empty .cursorignore if it doesn't exist
      touch "$TARGET/.cursorignore" 2>/dev/null
      echo -e "${GREEN}âœ“ Created empty .cursorignore${RESET}"
    fi
  fi
  
  if prompt_for_ignore_files "$TARGET" "Cursor" ".cursorindexingignore" "Controls which files Cursor will skip during indexing (improves performance)."; then
    if [ -f "${AINISH_CODER_DIR}/cursor/.cursorindexingignore" ]; then
      cp "${AINISH_CODER_DIR}/cursor/.cursorindexingignore" "$TARGET/" 2>/dev/null
      echo -e "${GREEN}âœ“ Deployed .cursorindexingignore${RESET}"
    else
      # Create empty .cursorindexingignore if it doesn't exist
      touch "$TARGET/.cursorindexingignore" 2>/dev/null
      echo -e "${GREEN}âœ“ Created empty .cursorindexingignore${RESET}"
    fi
  fi
  
  if [ -d "${AINISH_CODER_DIR}/cursor/.cursorrules" ]; then
    cp -r "${AINISH_CODER_DIR}/cursor/.cursorrules" "$TARGET/" 2>/dev/null
    echo -e "${GREEN}âœ“ Deployed .cursorrules/${RESET}"
  fi
  
  if [ -f "${AINISH_CODER_DIR}/cursor/my-license.mdc" ]; then
    cp "${AINISH_CODER_DIR}/cursor/my-license.mdc" "$TARGET/.cursor/rules/license.mdc" 2>/dev/null
    echo -e "${GREEN}âœ“ Deployed .cursor/rules/license.mdc${RESET}"
  fi

  # Deploy shared critical.mdc and PRD.mdc
  if [ -f "${AINISH_CODER_DIR}/critical.mdc" ]; then
    cp "${AINISH_CODER_DIR}/critical.mdc" "$TARGET/.cursor/rules/" 2>/dev/null
    echo -e "${GREEN}âœ“ Deployed critical.mdc to .cursor/rules/${RESET}"
  fi

  if [ -f "${AINISH_CODER_DIR}/PRD.mdc" ]; then
    cp "${AINISH_CODER_DIR}/PRD.mdc" "$TARGET/.cursor/rules/" 2>/dev/null
    echo -e "${GREEN}âœ“ Deployed PRD.mdc to .cursor/rules/${RESET}"
  fi

  # Verify files were created
  if [ -f "$TARGET/.cursorignore" ]; then
    echo -e "${GREEN}âœ“ Verified .cursorignore exists${RESET}"
  else
    echo -e "${YELLOW}âš ï¸ Warning: Failed to create .cursorignore${RESET}"
  fi
  
  if [ -f "$TARGET/.cursorindexingignore" ]; then
    echo -e "${GREEN}âœ“ Verified .cursorindexingignore exists${RESET}"
  else
    echo -e "${YELLOW}âš ï¸ Warning: Failed to create .cursorindexingignore${RESET}"
  fi

  echo -e "${BRIGHT_GREEN}âœ… Cursor configurations deployed to $TARGET${RESET}"
}

# Function to deploy only Aider configurations
deploy_aider_configs() {
  local TARGET="$1"

  # Verify target is a directory
  if [ ! -d "$TARGET" ]; then
    echo -e "${BRIGHT_RED}Error: $TARGET is not a directory${RESET}"
    return 1
  fi

  echo -e "${BRIGHT_BLUE}Deploying Aider configurations to $TARGET${RESET}"

  # Deploy Aider-specific configurations
  # Copy .aider-instructions.md from the root prompt.md
  local prompt_source="${REPO_DIR}/prompt.md"
  local aider_target_file="$TARGET/.aider-instructions.md"
  if [ -f "$prompt_source" ]; then
    cp "$prompt_source" "$aider_target_file" 2>/dev/null
    if [ $? -eq 0 ]; then
      echo -e "${GREEN}âœ“ Deployed $aider_target_file (from root prompt.md)${RESET}"
    else
      echo -e "${YELLOW}âš ï¸ Warning: Failed to deploy $aider_target_file${RESET}"
    fi
  else
    echo -e "${YELLOW}âš ï¸ Warning: Source prompt.md not found at $prompt_source${RESET}"
  fi
  
  if [ -f "${AINISH_CODER_DIR}/aider/.aider.conf.yml" ]; then
    cp "${AINISH_CODER_DIR}/aider/.aider.conf.yml" "$TARGET/" 2>/dev/null
    echo -e "${GREEN}âœ“ Deployed .aider.conf.yml${RESET}"
  fi
  
  if [ -f "${AINISH_CODER_DIR}/aider/.aiderignore" ]; then
    cp "${AINISH_CODER_DIR}/aider/.aiderignore" "$TARGET/" 2>/dev/null
    echo -e "${GREEN}âœ“ Deployed .aiderignore${RESET}"
  fi
  
  if [ -f "${AINISH_CODER_DIR}/aider/.env.example" ]; then
    cp "${AINISH_CODER_DIR}/aider/.env.example" "$TARGET/" 2>/dev/null
    echo -e "${GREEN}âœ“ Deployed .env.example${RESET}"
  fi

  if [ -f "${AINISH_CODER_DIR}/aider/aider-cli-commands.sh" ]; then
    cp "${AINISH_CODER_DIR}/aider/aider-cli-commands.sh" "$TARGET/" 2>/dev/null
    chmod +x "$TARGET/aider-cli-commands.sh" 2>/dev/null # Ensure executable
    echo -e "${GREEN}âœ“ Deployed aider-cli-commands.sh${RESET}"
  fi

  # Deploy shared critical.mdc and PRD.mdc directly to target directory
  if [ -f "${AINISH_CODER_DIR}/critical.mdc" ]; then
    cp "${AINISH_CODER_DIR}/critical.mdc" "$TARGET/" 2>/dev/null
    echo -e "${GREEN}âœ“ Deployed critical.mdc to $TARGET${RESET}"
  fi

  if [ -f "${AINISH_CODER_DIR}/PRD.mdc" ]; then
    cp "${AINISH_CODER_DIR}/PRD.mdc" "$TARGET/" 2>/dev/null
    echo -e "${GREEN}âœ“ Deployed PRD.mdc to $TARGET${RESET}"
  fi

  echo -e "${BRIGHT_GREEN}âœ… Aider configurations deployed to $TARGET${RESET}"
}

# Function to manage critical.mdc location during updates
update_critical_mdc() {
  echo -e "${BRIGHT_CYAN}ğŸ”„ Managing critical.mdc locations...${RESET}"

  # Check if root critical.mdc exists
  local source_file="${REPO_DIR}/critical.mdc"
  if [ ! -f "$source_file" ]; then
    echo -e "${BRIGHT_YELLOW}âš ï¸ Warning: Source critical.mdc not found: $source_file${RESET}"
    return 1
  fi

  # --- Ensure critical.mdc is PRESENT in required locations ---
  local updated_targets=0
  local required_present=(
    "${REPO_DIR}/ainish-aider/critical.mdc"
    "${REPO_DIR}/ainish-copilot/.github/critical.mdc"
    "${REPO_DIR}/ainish-cursor/.cursor/rules/critical.mdc"
  )
  for target_path in "${required_present[@]}"; do
    local target_dir=$(dirname "$target_path")
    # Ensure parent directory exists
    if [ ! -d "$target_dir" ]; then
       mkdir -p "$target_dir" 2>/dev/null
       if [ $? -ne 0 ]; then
          echo -e "${YELLOW}âš ï¸ Failed to create directory $target_dir${RESET}"
          continue # Skip if cannot create dir
       fi
    fi
    # Copy the file
    cp "$source_file" "$target_path" 2>/dev/null
    if [ $? -eq 0 ]; then
      echo -e "${GREEN}âœ“ Ensured/Updated $target_path${RESET}"
      updated_targets=$((updated_targets + 1))
    else
      echo -e "${YELLOW}âš ï¸ Failed to update $target_path${RESET}"
    fi
  done

  # --- Ensure critical.mdc is ABSENT from specific roots ---
  local removed_targets=0
  local required_absent=(
    "${REPO_DIR}/ainish-cursor/critical.mdc"
    "${REPO_DIR}/ainish-copilot/critical.mdc"
  )
  for target_file in "${required_absent[@]}"; do
    if [ -f "$target_file" ]; then
      rm -f "$target_file" 2>/dev/null
      if [ $? -eq 0 ]; then
        echo -e "${GREEN}âœ“ Removed $target_file${RESET}"
        removed_targets=$((removed_targets + 1))
      else
        echo -e "${YELLOW}âš ï¸ Failed to remove $target_file${RESET}"
      fi
    fi
  done
  if [ $removed_targets -gt 0 ]; then
     echo -e "${BLUE}âœ“ Ensured critical.mdc is removed from specific ainish-* roots.${RESET}"
  else
     echo -e "${BLUE}âœ“ critical.mdc already absent from specific ainish-* roots.${RESET}"
  fi

  echo -e "${BRIGHT_GREEN}âœ… critical.mdc location management complete${RESET}"
}

# Function to manage PRD.mdc location during updates
update_prd_mdc() {
  echo -e "${BRIGHT_CYAN}ğŸ”„ Managing PRD.mdc locations...${RESET}"

  # Check if root PRD.mdc exists
  local source_file="${REPO_DIR}/PRD.mdc"
  if [ ! -f "$source_file" ]; then
    echo -e "${BRIGHT_YELLOW}âš ï¸ Warning: Source PRD.mdc not found: $source_file${RESET}"
    return 1
  fi

  # --- Ensure PRD.mdc is PRESENT in required locations ---
  local updated_targets=0
  local required_present=(
    "${REPO_DIR}/ainish-aider/PRD.mdc"
    "${REPO_DIR}/ainish-copilot/.github/PRD.mdc"
    "${REPO_DIR}/ainish-cursor/.cursor/rules/PRD.mdc"
  )
  for target_path in "${required_present[@]}"; do
    local target_dir=$(dirname "$target_path")
    # Ensure parent directory exists
    if [ ! -d "$target_dir" ]; then
       mkdir -p "$target_dir" 2>/dev/null
       if [ $? -ne 0 ]; then
          echo -e "${YELLOW}âš ï¸ Failed to create directory $target_dir${RESET}"
          continue # Skip if cannot create dir
       fi
    fi
    # Copy the file
    cp "$source_file" "$target_path" 2>/dev/null
    if [ $? -eq 0 ]; then
      echo -e "${GREEN}âœ“ Ensured/Updated $target_path${RESET}"
      updated_targets=$((updated_targets + 1))
    else
      echo -e "${YELLOW}âš ï¸ Failed to update $target_path${RESET}"
    fi
  done

  # --- Ensure PRD.mdc is ABSENT from specific roots ---
  local removed_targets=0
  local required_absent=(
    "${REPO_DIR}/ainish-cursor/PRD.mdc"
    "${REPO_DIR}/ainish-copilot/PRD.mdc"
  )
  for target_file in "${required_absent[@]}"; do
    if [ -f "$target_file" ]; then
      rm -f "$target_file" 2>/dev/null
      if [ $? -eq 0 ]; then
        echo -e "${GREEN}âœ“ Removed $target_file${RESET}"
        removed_targets=$((removed_targets + 1))
      else
        echo -e "${YELLOW}âš ï¸ Failed to remove $target_file${RESET}"
      fi
    fi
  done
  if [ $removed_targets -gt 0 ]; then
     echo -e "${BLUE}âœ“ Ensured PRD.mdc is removed from specific ainish-* roots.${RESET}"
  else
     echo -e "${BLUE}âœ“ PRD.mdc already absent from specific ainish-* roots.${RESET}"
  fi

  echo -e "${BRIGHT_GREEN}âœ… PRD.mdc location management complete${RESET}"
}

# Function to manage prompt.md location during updates
update_prompt_md() {
  echo -e "${BRIGHT_CYAN}ğŸ”„ Managing prompt.md locations...${RESET}"

  # Check if root prompt.md exists
  local source_file="${REPO_DIR}/prompt.md"
  if [ ! -f "$source_file" ]; then
    echo -e "${BRIGHT_YELLOW}âš ï¸ Warning: Source prompt.md not found: $source_file${RESET}"
    return 1
  fi

  local updated_targets=0
  local aider_target="${REPO_DIR}/ainish-aider/.aider-instructions.md"
  local copilot_target_dir="${REPO_DIR}/ainish-copilot/.github"
  local copilot_target="${copilot_target_dir}/copilot-instructions.md"

  # Copy to Aider target
  cp "$source_file" "$aider_target" 2>/dev/null
  if [ $? -eq 0 ]; then
    echo -e "${GREEN}âœ“ Ensured/Updated $aider_target${RESET}"
    updated_targets=$((updated_targets + 1))
  else
    echo -e "${YELLOW}âš ï¸ Failed to update $aider_target${RESET}"
  fi

  # Copy to Copilot target
  mkdir -p "$copilot_target_dir" 2>/dev/null # Ensure dir exists
  cp "$source_file" "$copilot_target" 2>/dev/null
  if [ $? -eq 0 ]; then
    echo -e "${GREEN}âœ“ Ensured/Updated $copilot_target${RESET}"
    updated_targets=$((updated_targets + 1))
  else
    echo -e "${YELLOW}âš ï¸ Failed to update $copilot_target${RESET}"
  fi

  echo -e "${BRIGHT_GREEN}âœ… prompt.md location management complete${RESET}"
}

# Main execution
main() {
  # Check for command argument
  if [ "$1" == "deploy" ]; then
    # Deploy configurations to the specified directory
    deploy_ainish_configs "$2"
  elif [ "$1" == "deploy_vscode_configs" ]; then
    # Deploy VS Code configurations to the specified directory
    deploy_vscode_configs "$2"
  elif [ "$1" == "deploy_cursor_configs" ]; then
    # Deploy Cursor configurations to the specified directory
    deploy_cursor_configs "$2"
  elif [ "$1" == "deploy_aider_configs" ]; then
    # Deploy Aider configurations to the specified directory
    deploy_aider_configs "$2"
  elif [ "$1" == "update_critical_mdc" ]; then
    # Update critical.mdc in all ainish-* directories (standalone execution)
    update_critical_mdc
  elif [ "$1" == "update_prd_mdc" ]; then
    # Update PRD.mdc in all ainish-* directories (standalone execution)
    update_prd_mdc
  elif [ "$1" == "update_prompt_md" ]; then
    # Update prompt.md in all ainish-* directories (standalone execution)
    update_prompt_md
  elif [ "$1" == "update" ]; then
    # Run the full update process
    echo -e "${BRIGHT_CYAN}ğŸ”„ Running full AINISH-Coder update...${RESET}"
    update_critical_mdc # Ensure critical.mdc is up-to-date first
    update_prd_mdc # Ensure PRD.mdc is up-to-date
    update_prompt_md # Ensure prompt.md derived files are up-to-date
    echo ""
    # Run essential setup steps again
    cleanup_old_files
    setup_ainish_coder_dir
    verify_tool_paths # Check paths again in case they changed
    setup_wrapper_functions # Ensure wrappers are up-to-date
    echo -e "${BRIGHT_GREEN}âœ… Update process complete.${RESET}"
  else
    # Default: Run full initial setup
    # Print cyberpunk-style header
    echo -e "${BRIGHT_MAGENTA}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${RESET}"
    echo -e "${BRIGHT_MAGENTA}â•‘${RESET}               ${BRIGHT_CYAN}A I N I S H - C O D E R${RESET}                ${BRIGHT_MAGENTA}â•‘${RESET}"
    echo -e "${BRIGHT_MAGENTA}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"
    echo ""

    # Regular setup with automatic update
    echo -e "${BRIGHT_CYAN}ğŸ”§ [INIT] Setting up AINISH-Coder tooling configurations...${RESET}"
    echo ""
    
    # Automatically run update process first (same as update command)
    echo -e "${BRIGHT_CYAN}ğŸ”„ Automatically running update process...${RESET}"
    update_critical_mdc # Ensure critical.mdc is up-to-date first
    update_prd_mdc # Ensure PRD.mdc is up-to-date
    update_prompt_md # Ensure prompt.md derived files are up-to-date
    echo ""

    # Clean up old files
    cleanup_old_files

    # Setup ~/.ainish-coder directory
    setup_ainish_coder_dir

    # Verify tool paths
    if ! verify_tool_paths; then
      echo -e "${BRIGHT_YELLOW}âš ï¸  [WARN] Setup will continue but some tools may not work correctly.${RESET}"
      echo -e "${YELLOW}Please edit the path variables in $AINISH_CODER_DIR/ainish-setup.sh to fix this.${RESET}"
      echo ""
    fi

    # Make script executable
    chmod +x "$AINISH_CODER_DIR/ainish-setup.sh"

    # Set up wrapper functions
    setup_wrapper_functions
    
    echo -e "${BRIGHT_MAGENTA}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${RESET}"
    echo -e "${BRIGHT_MAGENTA}â•‘${RESET}               ${BRIGHT_GREEN}A I N I S H - C O D E R${RESET}            ${BRIGHT_MAGENTA}â•‘${RESET}"
    echo -e "${BRIGHT_MAGENTA}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"
    echo ""
    echo -e "${BRIGHT_CYAN}ğŸ”„ To activate all changes, run: ${BRIGHT_BLUE}source ~/.zshrc${RESET}"
    echo ""
    echo -e "${BRIGHT_MAGENTA}âœ¨ AVAILABLE COMMANDS:${RESET}"
    echo -e "${BRIGHT_BLUE}   â–¶ ainish-coder${RESET}: ${CYAN}Install all configurations to current directory${RESET}"
    echo -e "${BRIGHT_BLUE}   â–¶ ainish-cursor${RESET}: ${CYAN}Install Cursor configurations to current directory${RESET}"
    echo -e "${BRIGHT_BLUE}   â–¶ ainish-aider${RESET}: ${CYAN}Install Aider configurations to current directory${RESET}"
    echo -e "${BRIGHT_BLUE}   â–¶ ainish-copilot${RESET}: ${CYAN}Install VS Code configurations to current directory${RESET}"
    echo -e "${BRIGHT_BLUE}   â–¶ ainish-update${RESET}: ${CYAN}Update AINISH-Coder from the repository${RESET}"
    echo ""
    echo -e "${BRIGHT_GREEN}ğŸ”— SYMLINKED CONFIGURATION:${RESET}"
    echo -e "${GREEN}   Your AINISH-Coder installation is now symlinked to your repository at:${RESET}"
    echo -e "${CYAN}   $REPO_DIR${RESET}"
    echo -e "${GREEN}   Changes to repository files will be immediately available to the tools${RESET}"
    echo -e "${GREEN}   without needing to rerun the setup script.${RESET}"
    echo ""
  fi
}

# Execute main function
main "$@"